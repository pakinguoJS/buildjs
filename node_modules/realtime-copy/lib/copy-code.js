var FS 		= require('fs');
var PATH	= require('path');

module.exports = {
	delegate:	delegate,
	delegateAt: delegateAt
};


/**
 * @param		{string}		base		文件夹路径
 * @param		{Array}			list		监听的对象
 * 遵循以下数据结构:
 * [{
 * 		src: "",
 * 		dist: "",
 * 		ignore: /reg/,
 * 		unfold: false
 * }, ...]
 * @desc
 *
 */
function delegate(src, list){
	// 校验参数
	if(arguments.length < 2){
		return;
	}
	if(typeof src !== 'string' && !(list instanceof Array)){
		throw('Type of arguments is error, please check it right!');
		return;
	}
	
	
	// 监听
	list.forEach(function(itm, idx){
		realTimeWatch(src, itm);
	})
	
	
	/**
	 * @param		{string}		base		文件夹路径
	 * @param		{object}		item		监听的对象
	 * @desc
	 * item数据结构如下：
	 * {
	 * 		src: "",
	 * 		dist: "",
	 * 		ignore: /reg/,
	 * 		unfold: false
	 * }
	 */
	function realTimeWatch(base, item){
		var _src  = PATH.join(base, item.src);
		var _dist = PATH.join(base, item.dist);
		var _viewDist = PATH.join(base, item.view_dist || 'views');
		var _fileType = item.view_type || /\.tpl$/;
		
		// 先copy，确保监听的文件夹存在
		if(!FS.existsSync(_dist)){
			copyDir(_src, _dist, item.ignore);
		}
		
		innerWatch(_src);
		
		
		/**
		 * @param		{string}		src		监听的源文件路径
		 * @desc		实现逻辑：
		 * 监听源文件夹下所有文件（夹）的相关变动，再进行两次比较：目标文件夹->源文件夹、源文件夹->目标文件夹
		 * 目标文件夹->源文件夹：确保目标文件夹下所有文件都与源同步
		 * 源文件夹->目标文件夹：再将源文件夹新增的文件（夹）与目标文件夹同步
		 * 所有比较都是全文件夹遍历一遍【TODO，性能有待提高】
		 */
		function innerWatch(src){
			// 如果是监听的文件夹重命名或删除，则停止脚本
			if(!FS.existsSync(src)){
				return;
			}
			var _list = FS.readdirSync(src);
			
			// 监听文件夹前，需要先取消监听，再重新监听
			FS.watchFile(src, function() {
				innerUnwatch(src);
				innerWatch(src);
			});
			
			_list.forEach(function(name, idx){
				var filePath = PATH.join(src, name);
				var stat = FS.statSync(filePath);
                if (stat.isDirectory()) {
					FS.watchFile(filePath, function(curr, prev) {
						innerCompareDist2Src(_dist);
						innerCompareSrc2Dist(_src);
						compareTpl(_src);
						console.log('Change Dir: ' + filePath);
					});
					innerWatch(filePath);
                } else {
                    FS.watchFile(filePath, function(curr, prev) {
						innerCompareDist2Src(_dist);
						innerCompareSrc2Dist(_src);
						compareTpl(_src);
						console.log('Change File: ' + filePath);
					});
                }
			});
		}
		
		
		/**
		 * @param		{string}		src		解除所有监听事件的源文件夹路径
		 */
		function innerUnwatch(src) {
			if(!FS.existsSync(src)){
				return;
			}
			if(FS.statSync(src).isDirectory()){
				var _list = FS.readdirSync(src);
				FS.unwatchFile(src);
				_list.forEach(function(name, idx) {
					var filePath = PATH.join(src, name);
					var stat = FS.statSync(filePath);
					if (stat.isDirectory()) {
						innerUnwatch(filePath);
					} else {
						FS.unwatchFile(filePath);
					}
				});
			}else{
				FS.unwatchFile(src);
			}
        }
		
		
		/**
		 * @param		{string}		dist	
		 * @desc		目标文件夹->源文件夹
		 */
		function innerCompareDist2Src(dist){
			var _list = FS.readdirSync(dist);
			_list.forEach(function(name){
				var _distPath = PATH.join(dist, name);
				var _srcPath = _distPath.replace(_dist, _src);
				// 如果目标与源不对应存在，则删除目标文件
				if(!FS.existsSync(_srcPath)){
					rmdir(_distPath);
				}else{
					// 如果存在，且是文件夹，则递归继续对比
					if(FS.statSync(_distPath).isDirectory()){
						innerCompareDist2Src(_distPath);
					}else{
						// 如果存在且是文件，则做对比，文件一致不动作，不一致
						if(FS.readFileSync(_srcPath) !== FS.readFileSync(_distPath)){
							copyFile(_srcPath, _distPath);
						}
					}
				}
			})
		}
		
		
		/**
		 * @param		{string}		dist	
		 * @desc		源文件夹->目标文件夹
		 */
		function innerCompareSrc2Dist(src){
			var _list = FS.readdirSync(src);
			_list.forEach(function(name){
				// 可以忽略比较的配置项
				if(item.ignore && item.ignore.test(name)){
					return;
				}
			
				var _srcPath = PATH.join(src, name);
				var _distPath = _srcPath.replace(_src, _dist);
				// 如果源文件夹中存在目标文件夹所没有的文件，则复制
				if(FS.statSync(_srcPath).isDirectory()){
					innerCompareSrc2Dist(_srcPath);
					if(!(item.ignore && item.ignore.test(name))){
						mkdir(_distPath);
					}
				}else{
					if(!FS.existsSync(_distPath)){
						// 是否需要扁平化复制的文件
						if(item.unfold){
							copyFile(filePath, PATH.join(_dist, name));
						}else{
							copyFile(_srcPath, _distPath);
						}
					}
				}
			})
		}
		
		
		/**
		 * @param		{string}		dist	
		 * @desc		源文件夹->目标文件夹
		 */
		function compareTpl(src){
			var _list = FS.readdirSync(src);
			_list.forEach(function(name){
				var _srcPath = PATH.join(src, name);
				if(FS.statSync(_srcPath).isDirectory()){
					compareTpl(_srcPath);
				}else{
					if(_fileType.test(PATH.extname(name))){
						var _distPath = PATH.join(_viewDist, name);
						// 如果源文件不存在，目标文件存在，则删除目标文件
						if(!FS.existsSync(_srcPath) && FS.existsSync(_distPath)){
							rmdir(_distPath);
						}else if(FS.existsSync(_distPath) && (FS.readFileSync(_srcPath, 'utf-8') === FS.readFileSync(_distPath, 'utf-8'))){
							// 判断两个文件是否一样，一样则不执行
							return;
						}else{
							// 否则执行复制
							copyFile(_srcPath, _distPath);
						}
					}
				}
			})
		}
		
	}
	
	
	/**
	 * @param		{string}		from	复制源	
	 * @param		{string}		to		目标
	 * @desc		
	 */
	function copyFile(from, to){
		var dir = PATH.dirname(to);
		mkdir(dir);
		try{
			FS.writeFileSync(to, FS.readFileSync(from));
		}catch(e){
			if(FS.existsSync(to)){
				FS.unlinkSync(to);
			}
		}
	}
	
	
	/**
	 * @param		{string}		from	复制源	
	 * @param		{string}		to		目标
	 * @desc		
	 */
	function copyDir(from, to, ignore){
		if(!FS.existsSync(from)){
			if(FS.existsSync(to)){
				rmdir(to);
			}
			return;
		}
		var _list = FS.readdirSync(from);
		mkdir(to);
		_list.forEach(function(name, idx) {
			if(ignore && ignore.test(name)){
				return;
			}
			var filePath = PATH.join(from, name);
			var stat = FS.statSync(filePath);
			if (stat.isDirectory()) {
				copyDir(filePath, PATH.join(to, name), ignore);
			} else {
				copyFile(filePath, PATH.join(to, name));
			}
		});
	}
	
	function mkdir(dir){
		if(!FS.existsSync(dir)){
			var _path = dir.split(/\/|\\/);
			if(_path.length === 1){
				return;
			}
			_path.pop();
			mkdir(_path.join('/'));
			FS.mkdirSync(dir);
		}
	}
	
	function rmdir(dir){
		if(!FS.statSync(dir).isDirectory()){
			FS.unlinkSync(dir);
			return;
		}
	
		var _list = FS.readdirSync(dir);
		_list.forEach(function(name, idx){
			var _path = PATH.join(dir, name);
			if(FS.statSync(_path).isDirectory()){
				rmdir(_path);
			}else{
				FS.unlinkSync(_path);
			}
		});
		FS.rmdirSync(dir);
	}
}




function delegateAt(src, dist, filetype){
	// 校验参数
	if(arguments.length < 3){
		return;
	}
	if(typeof src !== 'string' && typeof dist !== 'string' && !(filetype instanceof RegExp)){
		throw('Type of arguments is error, please check it right!');
		return;
	}
	realTimeWatch();
	
	
	/**
	 * @param		{string}		base		文件夹路径
	 * @param		{object}		item		监听的对象
	 * @desc
	 */
	function realTimeWatch(){
		var _src  = src;
		var _dist = dist;
		var _fileType = filetype || /\.tpl$/;
		
		// 先copy，确保监听的文件夹存在
		if(!FS.existsSync(_dist)){
			mkdir(_dist)
		}
		
		innerWatch(_src);
		
		
		/**
		 * @param		{string}		src		监听的源文件路径
		 * @desc		实现逻辑：
		 * 监听源文件夹下所有文件（夹）的相关变动，再进行两次比较：目标文件夹->源文件夹、源文件夹->目标文件夹
		 * 目标文件夹->源文件夹：确保目标文件夹下所有文件都与源同步
		 * 源文件夹->目标文件夹：再将源文件夹新增的文件（夹）与目标文件夹同步
		 * 所有比较都是全文件夹遍历一遍【TODO，性能有待提高】
		 */
		function innerWatch(src){
			// 如果是监听的文件夹重命名或删除，则停止脚本
			if(!FS.existsSync(src)){
				return;
			}
			var _list = FS.readdirSync(src);
			
			// 监听文件夹前，需要先取消监听，再重新监听
			FS.watchFile(src, function() {
				innerUnwatch(src);
				innerWatch(src);
			});
			
			_list.forEach(function(name, idx){
				var filePath = PATH.join(src, name);
				var stat = FS.statSync(filePath);
                if (stat.isDirectory()) {
					FS.watchFile(filePath, function(curr, prev) {
						innerCompare(_src);
					});
					innerWatch(filePath);
                } else {
                    FS.watchFile(filePath, function(curr, prev) {
						innerCompare(_src);
					});
                }
			});
		}
		
		
		/**
		 * @param		{string}		src		解除所有监听事件的源文件夹路径
		 */
		function innerUnwatch(src) {
			if(!FS.existsSync(src)){
				return;
			}
			if(FS.statSync(src).isDirectory()){
				var _list = FS.readdirSync(src);
				FS.unwatchFile(src);
				_list.forEach(function(name, idx) {
					var filePath = PATH.join(src, name);
					var stat = FS.statSync(filePath);
					if (stat.isDirectory()) {
						innerUnwatch(filePath);
					} else {
						FS.unwatchFile(filePath);
					}
				});
			}else{
				FS.unwatchFile(src);
			}
        }
		
		
		/**
		 * @param		{string}		dist	
		 * @desc		源文件夹->目标文件夹
		 */
		function compareTpl(src){
			var _list = FS.readdirSync(src);
			_list.forEach(function(name){
				var _srcPath = PATH.join(src, name);
				if(FS.statSync(_srcPath).isDirectory()){
					compareTpl(_srcPath);
				}else{
					if(_fileType.test(PATH.extname(name))){
						var _distPath = PATH.join(_dist, name);
						// 判断目标文件是否存在，如果存在，则判断两个文件是否一样，
						if(FS.existsSync(_distPath) && (FS.readFileSync(_srcPath, 'utf-8') === FS.readFileSync(_distPath, 'utf-8'))){
							return;
						}else{
							copyFile(_srcPath, _distPath);
						}
					}
				}
			})
		}
	}
	
	
	/**
	 * @param		{string}		from	复制源	
	 * @param		{string}		to		目标
	 * @desc		
	 */
	function copyFile(from, to){
		var dir = PATH.dirname(to);
		mkdir(dir);
		try{
			FS.writeFileSync(to, FS.readFileSync(from));
		}catch(e){
			if(FS.existsSync(to)){
				FS.unlinkSync(to);
			}
		}
	}
	
	
	/**
	 * @param		{string}		from	复制源	
	 * @param		{string}		to		目标
	 * @desc		
	 */
	function copyDir(from, to, ignore){
		if(!FS.existsSync(from)){
			if(FS.existsSync(to)){
				rmdir(to);
			}
			return;
		}
		var _list = FS.readdirSync(from);
		mkdir(to);
		_list.forEach(function(name, idx) {
			if(ignore && ignore.test(name)){
				return;
			}
			var filePath = PATH.join(from, name);
			var stat = FS.statSync(filePath);
			if (stat.isDirectory()) {
				copyDir(filePath, PATH.join(to, name), ignore);
			} else {
				copyFile(filePath, PATH.join(to, name));
			}
		});
	}
	
	function mkdir(dir){
		if(!FS.existsSync(dir)){
			var _path = dir.split(/\/|\\/);
			if(_path.length === 1){
				return;
			}
			_path.pop();
			mkdir(_path.join('/'));
			FS.mkdirSync(dir);
		}
	}
	
	function rmdir(dir){
		if(!FS.statSync(dir).isDirectory()){
			FS.unlinkSync(dir);
			return;
		}
	
		var _list = FS.readdirSync(dir);
		_list.forEach(function(name, idx){
			var _path = PATH.join(dir, name);
			if(FS.statSync(_path).isDirectory()){
				rmdir(_path);
			}else{
				FS.unlinkSync(_path);
			}
		});
		FS.rmdirSync(dir);
	}
}